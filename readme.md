Spring容器手写流程：

从xml解析beanDefinition，根据情况实例化bean，然后存储到一个容器中，以供使用。

applicationContext使用reader解析resource得到beanDefinition，其中reader通过注入beanFactory，得到加载beanDefinition的能力。解析即是将resource中配置的属性读取出来放到beanDefinition中，加载是将beanDefinition放到beanFactory中。加载到beanFactory中之后，将beanDefinition实例化成真正的bean对象，并存放到singletonBeanRegistry里。加载完毕就可以通过applicationContext.getBean()获取加载好的bean对象进行使用。

此外，容器支持setter注入和构造器注入，这两个能力在reader解析resource的过程中，存放到beanDefinition中的argumentValues和propertyValues中，然后在simpleBeanFactory中依次遍历两个列表，通过反射创建对应的bean对象并注入bean对象的属性。

除了一般类型的属性之外，bean可能嵌套依赖bean，此时，为propertyValue新增isRef字段，用于判断该属性是否是一个依赖，如果是则通过createBean方法创建它，形成一个调用链，最终创建出所有依赖的bean。

不过这样有一个问题，如果一个beanA依赖beanB，在解析resource时没有先解析出beanB，创建beanA的beanB属性时则会抛出没有这个bean的错误。在这个过程中，beanA除了没有设置beanB属性，它基本已经实例化好了，因此，在这个环节增加一个逻辑，就可以解决循环依赖的问题。具体来说，在beanA实例化到最后一步时（即还没有beanB属性），将beanA对象先存放到一个地方earlySingletonObjects，然后开始实例化beanB，由于beanB没有依赖其他bean，所以可以实例化成功，最后再把存储未完成的beanA拿出来设置beanB，这样就实例化完成了。这个例子还比较简单，更复杂一点的场景，是a、b相互依赖，a依赖b、b依赖c、c依赖a等等，同理，也可以使用这个逻辑进行处理。总的来说，解决bean循环依赖是把相互依赖的所有bean的实例化作为一个整体来创建。

将以上所述内容整体包装一下，对外提供一个refresh方法，封装所有细节，作为容器启动的入口。这个方法包含容器启动的各个步骤，从bean工厂的创建，到bean对象的实例化、初始化，最后到容器加载，一切的bean处理都在这里完成。

在xml中配置ref注入bean不够方便，这就引出了注解注入。虽说注解方便了bean的注入和使用，但作为程序来说它还是在看不见的地方完成了xml的ref所做的事情。注解作用在实例变量上时，想要注解生效，则对象必须创建好，因此，做这个事情就在createBean之后。refresh方法就是遍历所有的beanDefinitaion创建所有的bean，在这个方法中就可以在bean初始化前、中、后分别对bean进行处理，也就是postProcessBeforeInitialization、init-method、postProcessAfterInitialization。具体做法应该是通过反射获取标注了注解的成员变量，把它初始化成bean然后注入属性


